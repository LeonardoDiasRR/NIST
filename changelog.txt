
NIST27\NIST\NIST\fingerprint\functions.py:
Before:
    from cStringIO import StringIO, InputType, OutputType
After:
    from io import StringIO
Before:
    elif isinstance( input, ( OutputType, InputType ) ):
After:
    elif isinstance( input, StringIO ):
Justify:
    There io.StringIO  Python 3 module substituted the cStringIO in Python2.7

NIST30\MDmisc\MDmisc\DefaultOrderedDict.py:
Before:
    from collections import OrderedDict, Callable
After:
    from collections import OrderedDict
    from collections.abc import Callable

Justify:
    Callable is moved form collections.abc to collections.abc


NIST3\NIST\NIST\traditional\__init__.py
Before:
    from io import StringIO, BufferedReader
After:
    from io import StringIO

Before:
        elif isinstance( p, ( cStringIO.OutputType ) ):
            self.load( p.getvalue() )
        
        elif isinstance( p, ( file ) ):
            self.load( p.read() )            
After:
        elif isinstance( p, ( StringIO ) ):
            self.load( p.getvalue() )
        
        elif isinstance( p, ( bytes ) ):
            self.load( p )
        
        elif isinstance( p, ( IOBase ) ):
            self.load( p.read() )
Added:
        if isinstance(data, bytes):
            data = data.decode('iso-8859-1')

Justify:
    Necessary to decode binary data to str, becouse Python 2.7 reads binary as str 


NIST3\NIST\NIST\core\__init__.py
Added:
    data = data.decode('iso-8859-1')
Justify:
    Python2.7 reads binary data as 'str', while Python 3 reads binary data as 'bytes', 
    so I decoded the data from 'bytes' to 'str'

NIST3\MDmisc\MDmisc\binary.py
Before:
    binstring = [ oct2bin[int( n )] for n in oct( x ) ]
After:
    binstring = [ oct2bin[int( n )] for n in '0' + oct( x )[2:] ]  # Patch for Python 3
Justify:
    In Python 3, the oct() function still converts an integer to its octal representation, 
    but the returned string uses the prefix '0o' (zero and lowercase letter 'o') 
    to clearly indicate octal values. It was necessary to remove the 'o' letter
Ex.:
    # Python 3
    octal_string = oct(8)
    print(octal_string)  # Output: "0o10"

NIST3\NIST\NIST\core\functions.py
Before:
    range( n / 2 )
After:
    range( int(n / 2) )
Justify:
    range() function in Python 3 does not works with float values like Python 2.7

NIST3\MDmisc\MDmisc\binary.py
Before:
    range( nbytes )
    range( nbites )
After:    
    range( int(nbytes) )
    range( int(nbites) )
Justify:
    range() function in Python 3 does not works with float values like Python 2.7

NIST3\NIST\NIST\traditional\__init__.py
Before:
    return "".join( outnist )
After:
    return ("".join( outnist )).encode('iso-8859-1')
Justify:
    Needed to encod data from 'str' to 'bytes'


NIST3\NIST\NIST\core\__init__.Python
Before:
    return self.data[ ntype ][ idc ][ tagid ]
After:
    if tagid == 999:
        binary_data = self.data[ ntype ][ idc ][ tagid ]
        return binary_data.encode('iso-8859-1')
Justify:
    Needed to encode to bytes when the data is a binary (tagid=999)


NIST3\NIST\NIST\core\functions.py
Added:
    if isinstance(data, bytes):
        data = data.decode('iso-8859-1')
Justify:
    After change the function get_field() to return binary data when tagid = 999, it was necessary to 
    decode the data from 'bytes' to 'str' in the function bindump()